/*
 * Copyright 2025 Frans Jacobs.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package jcs.ui.layout;

import java.awt.Component;
import java.awt.Dimension;
import java.awt.Image;
import java.awt.Point;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.dnd.DnDConstants;
import java.awt.dnd.DragGestureEvent;
import java.awt.dnd.DragGestureListener;
import java.awt.dnd.DragGestureRecognizer;
import java.awt.dnd.DragSource;
import java.awt.dnd.DragSourceDragEvent;
import java.awt.dnd.DragSourceDropEvent;
import java.awt.dnd.DragSourceEvent;
import java.awt.dnd.DragSourceListener;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import javax.swing.DefaultListCellRenderer;
import javax.swing.ImageIcon;
import javax.swing.JList;
import jcs.entities.TileBean.Direction;
import jcs.entities.TileBean.Orientation;
import jcs.entities.TileBean.TileType;

import org.tinylog.Logger;

/**
 *
 * Drag and Drop dialog. This is the drag source for the Track components
 */
public class TrackTileDialog extends javax.swing.JDialog {

  private static final long serialVersionUID = 6774576750704893774L;

  private final LayoutCanvas layoutCanvas;
  private final Map<String, String> tileIcons;

  private final static String[] COMPONENTS = new String[]{
    "Straight", "Straight Direction", "Curved", "Sensor", "Signal", "Turnout Left", "Turnout Right", "Cross Left", "Cross Right", "Crossing", "End Track"};

  /**
   * Creates new form TileNewJDialog
   */
  public TrackTileDialog(java.awt.Frame parent, boolean modal, LayoutCanvas layoutCanvas) {
    super(parent, modal);
    tileIcons = new HashMap<>();
    this.layoutCanvas = layoutCanvas;
    initTileIcons();
    initComponents();

    componentsList.setCellRenderer(new IconCellRenderer());
    componentsList.setListData(COMPONENTS);
    //this.componentsList.setTransferHandler(new ListTransferHandler());

    DragGestureRecognizer dgr = DragSource.getDefaultDragSource().createDefaultDragGestureRecognizer(
            componentsList,
            DnDConstants.ACTION_COPY_OR_MOVE,
            new DragGestureHandler(componentsList));

  }

  private void initTileIcons() {

    tileIcons.put("Straight", "/media/new-straight.png");
    tileIcons.put("Straight Direction", "/media/new-straightDirection.png");
    tileIcons.put("Curved", "/media/new-diagonal.png");
    tileIcons.put("Sensor", "/media/new-straight-feedback.png");
    tileIcons.put("Signal", "/media/new-straight-signal.png");
    tileIcons.put("Sensor", "/media/new-straight-feedback.png");
    tileIcons.put("Turnout Left", "/media/new-L-turnout.png");
    tileIcons.put("Turnout Right", "/media/new-R-turnout.png");
    tileIcons.put("Cross Left", "/media/new-cross-L.png");
    tileIcons.put("Cross Right", "/media/new-cross-R.png");
    tileIcons.put("Crossing", "/media/new-crossing.png");
    tileIcons.put("End Track", "/media/new-end-track.png");
  }

  @Override
  public void setVisible(boolean b) {
    if (b) {
      Point p;
      if (layoutCanvas == null) {
        p = getLocationOnScreen();
      } else {
        p = layoutCanvas.getLocationOnScreen();
      }

      pack();
      Logger.trace("Canvas P  x: " + p.x + " y: " + p.y);

      Point d = new Point(p.x - (getWidth() + 40), p.y);
      setLocation(d);
    }
    super.setVisible(b);
  }

  /**
   * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The content of this method is always regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    mainPanel = new javax.swing.JPanel();
    componentSP = new javax.swing.JScrollPane();
    componentsList = new javax.swing.JList<>();

    setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

    mainPanel.setLayout(new java.awt.BorderLayout());

    componentsList.setModel(new javax.swing.AbstractListModel<String>() {
      String[] strings = { "Straight", "Straight Direction", "Curved", "Sensor", "Signal", "Turnout Left", "Turnout Right", "Cross Left", "Cross Right", "Crossing", "End Track", " " };
      public int getSize() { return strings.length; }
      public String getElementAt(int i) { return strings[i]; }
    });
    componentsList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
    componentsList.setDragEnabled(true);
    componentsList.addListSelectionListener(new javax.swing.event.ListSelectionListener() {
      public void valueChanged(javax.swing.event.ListSelectionEvent evt) {
        componentsListValueChanged(evt);
      }
    });
    componentSP.setViewportView(componentsList);

    mainPanel.add(componentSP, java.awt.BorderLayout.CENTER);

    getContentPane().add(mainPanel, java.awt.BorderLayout.CENTER);

    pack();
  }// </editor-fold>//GEN-END:initComponents

  private void componentsListValueChanged(javax.swing.event.ListSelectionEvent evt) {//GEN-FIRST:event_componentsListValueChanged
    if (!evt.getValueIsAdjusting()) {
      Logger.trace("Selected tile: " + this.componentsList.getSelectedValue());
    }
  }//GEN-LAST:event_componentsListValueChanged

  public class IconCellRenderer extends DefaultListCellRenderer {

    private static final long serialVersionUID = 8061623542665324932L;

    @Override
    public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {
      // Let superclass deal with most of it...
      super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);

      String iconPath = tileIcons.get((String) value);

      final ImageIcon imageIcon = new ImageIcon(getClass().getResource(iconPath));

      Image image = imageIcon.getImage();
      final Dimension dimension = this.getPreferredSize();
      final double height = dimension.getHeight();
      final double width = (height / imageIcon.getIconHeight()) * imageIcon.getIconWidth();
      image = image.getScaledInstance((int) width, (int) height, Image.SCALE_SMOOTH);
      final ImageIcon finalIcon = new ImageIcon(image);
      setIcon(finalIcon);
      return this;
    }
  }

  class DragSourceHandler implements DragSourceListener {

    @Override
    public void dragEnter(DragSourceDragEvent dsde) {
    }

    @Override
    public void dragOver(DragSourceDragEvent dsde) {
    }

    @Override
    public void dropActionChanged(DragSourceDragEvent dsde) {
    }

    @Override
    public void dragExit(DragSourceEvent dse) {
    }

    @Override
    public void dragDropEnd(DragSourceDropEvent dsde) {
      Logger.trace("Drag finished...");
    }

  }

  public static class TileDesc {

    private final String name;
    private final String tileType;
    private final String tileOrientation;
    private final String tileDirection;

    public TileDesc(String name, String tileType, String tileOrientation, String tileDirection) {
      this.name = name;
      this.tileType = tileType;
      this.tileOrientation = tileOrientation;
      this.tileDirection = tileDirection;
    }

    public String getName() {
      return name;
    }

    public String getTileType() {
      return tileType;
    }

    public String getTileOrientation() {
      return tileOrientation;
    }

    public String getTileDirection() {
      return tileDirection;
    }

    @Override
    public String toString() {
      return name;
    }
  }

  class DragGestureHandler implements DragGestureListener {

    private final JList list;

    public DragGestureHandler(JList list) {
      this.list = list;
    }

    @Override
    public void dragGestureRecognized(DragGestureEvent dge) {
      String selectedValue = (String) list.getSelectedValue();

      TileDesc tileDesc = createTileDesc(selectedValue);

      Transferable t = new TileDescTransferable(tileDesc);
      DragSource ds = dge.getDragSource();
      //ds.startDrag(dge, null, t, new DragSourceHandler());
      dge.startDrag(null, t);
    }

  }

  private TileType getTileType(String name) {
    switch (name) {
      case "Straight" -> {
        return TileType.STRAIGHT;
      }
      case "Straight Direction" -> {
        return TileType.STRAIGHT_DIR;
      }
      case "Curved" -> {
        return TileType.CURVED;
      }
      case "Sensor" -> {
        return TileType.SENSOR;
      }
      case "Signal" -> {
        return TileType.SIGNAL;
      }
      case "Turnout Left" -> {
        return TileType.SWITCH;
      }
      case "Turnout Right" -> {
        return TileType.SWITCH;
      }
      case "Cross Left" -> {
        return TileType.CROSS;
      }
      case "Cross Right" -> {
        return TileType.CROSS;
      }
      case "Crossing" -> {
        return TileType.CROSSING;
      }
      case "End Track" -> {
        return TileType.END;
      }
      default -> {
        Logger.warn(name + " is unknown");
        return TileType.STRAIGHT;
      }
    }
  }

  private TileDesc createTileDesc(String name) {
    TileType tileType = getTileType(name);
    Orientation orientation = this.layoutCanvas.getOrientation();
    Direction direction = this.layoutCanvas.getDirection();

    Logger.trace("Creating: " + tileType + " O: " + orientation + " D: " + direction);
    return new TileDesc(name, tileType.getTileType(), orientation.getOrientation(), direction.getDirection());
  }

  public static class TileDescTransferable implements Transferable {

    public static final DataFlavor USER_DATA_FLAVOR = new DataFlavor(TileDesc.class, "TileDesc");
    private final TileDesc tileDesc;

    public TileDescTransferable(TileDesc tileDesc) {
      this.tileDesc = tileDesc;
    }

    @Override
    public DataFlavor[] getTransferDataFlavors() {
      return new DataFlavor[]{USER_DATA_FLAVOR};
    }

    @Override
    public boolean isDataFlavorSupported(DataFlavor flavor) {
      return USER_DATA_FLAVOR.equals(flavor);
    }

    @Override
    public Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException, IOException {
      Object value = null;
      if (USER_DATA_FLAVOR.equals(flavor)) {
        value = tileDesc;
      } else {
        throw new UnsupportedFlavorException(flavor);
      }
      return value;
    }
  }


  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JScrollPane componentSP;
  private javax.swing.JList<String> componentsList;
  private javax.swing.JPanel mainPanel;
  // End of variables declaration//GEN-END:variables
}
