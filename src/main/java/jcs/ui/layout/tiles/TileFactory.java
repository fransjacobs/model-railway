/* * Copyright 2023 Frans Jacobs. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package jcs.ui.layout.tiles;import java.awt.Point;import java.util.LinkedList;import java.util.List;import jcs.JCS;import jcs.commandStation.events.AccessoryEventListener;import jcs.commandStation.events.SensorEventListener;import jcs.entities.AccessoryBean;import jcs.entities.SensorBean;import jcs.entities.TileBean;import jcs.entities.TileBean.Direction;import jcs.entities.TileBean.Orientation;import static jcs.entities.TileBean.TileType.BLOCK;import static jcs.entities.TileBean.TileType.CROSS;import static jcs.entities.TileBean.TileType.CROSSING;import static jcs.entities.TileBean.TileType.CURVED;import static jcs.entities.TileBean.TileType.END;import static jcs.entities.TileBean.TileType.SENSOR;import static jcs.entities.TileBean.TileType.SIGNAL;import static jcs.entities.TileBean.TileType.STRAIGHT;import static jcs.entities.TileBean.TileType.STRAIGHT_DIR;import static jcs.entities.TileBean.TileType.SWITCH;import org.tinylog.Logger;/** * Factory object to create Tiles and cache tiles * * @author frans */public class TileFactory {  // Keep the records of the used id sequence number  private static int straightIdSeq;  private static int crossingIdSeq;  private static int curvedIdSeq;  private static int switchIdSeq;  private static int crossIdSeq;  private static int signalIdSeq;  private static int sensorIdSeq;  private static int blockIdSeq;  private static int straightDirectionIdSeq;  private static int endIdSeq;  private TileFactory() {  }  private static int nextIdSeq(String id) {    String idnr = id.substring(3);    int idSeq = Integer.parseInt(idnr);    return idSeq;  }  private static String nextTileId(TileBean.TileType tileType) {    switch (tileType) {      case STRAIGHT -> {        straightIdSeq++;        return "st-" + straightIdSeq;      }      case CROSSING -> {        crossingIdSeq++;        return "cr-" + crossingIdSeq;      }      case CURVED -> {        curvedIdSeq++;        return "ct-" + curvedIdSeq;      }      case SWITCH -> {        switchIdSeq++;        return "sw-" + switchIdSeq;      }      case CROSS -> {        crossIdSeq++;        return "cs-" + crossIdSeq;      }      case SIGNAL -> {        signalIdSeq++;        return "si-" + signalIdSeq;      }      case SENSOR -> {        sensorIdSeq++;        return "se-" + sensorIdSeq;      }      case BLOCK -> {        blockIdSeq++;        return "bk-" + blockIdSeq;      }      case STRAIGHT_DIR -> {        straightDirectionIdSeq++;        return "sd-" + straightDirectionIdSeq;      }      case END -> {        endIdSeq++;        return "et-" + endIdSeq;      }      default -> {        Logger.warn("Unknown Tile Type " + tileType);        return null;      }    }  }  private static int maxIdSeq(int currentId, int newId) {    if (currentId < newId) {      return newId;    } else {      return currentId;    }  }  public static Tile createTile(String tileId) {    TileBean tileBean = JCS.getPersistenceService().getTileBean(tileId);    return createTile(tileBean);  }  public static Tile createTile(TileBean tileBean) {    return createTile(tileBean, false);  }  public static Tile createTile(TileBean tileBean, boolean showValues) {    if (tileBean == null) {      return null;    }    TileBean.TileType tileType = tileBean.getTileType();    Tile tile = null;    switch (tileType) {      case STRAIGHT -> {        tile = new Straight(tileBean);        straightIdSeq = maxIdSeq(straightIdSeq, nextIdSeq(tileBean.getId()));      }      case CROSSING -> {        tile = new Crossing(tileBean);        crossingIdSeq = maxIdSeq(crossingIdSeq, nextIdSeq(tileBean.getId()));      }      case CURVED -> {        tile = new Curved(tileBean);        curvedIdSeq = maxIdSeq(curvedIdSeq, nextIdSeq(tileBean.getId()));      }      case SWITCH -> {        tile = new Switch(tileBean);        tile.setAccessoryBean(tileBean.getAccessoryBean());        switchIdSeq = maxIdSeq(switchIdSeq, nextIdSeq(tileBean.getId()));        if (showValues && tileBean.getAccessoryBean() != null) {          tile.setAccessoryValue((tileBean.getAccessoryBean()).getAccessoryValue());        }        JCS.getJcsCommandStation().addAccessoryEventListener((AccessoryEventListener) tile);      }      case CROSS -> {        tile = new Cross(tileBean);        tile.setAccessoryBean(tileBean.getAccessoryBean());        crossIdSeq = maxIdSeq(crossIdSeq, nextIdSeq(tileBean.getId()));        if (showValues && tileBean.getAccessoryBean() != null) {          tile.setAccessoryValue((tileBean.getAccessoryBean()).getAccessoryValue());        }        JCS.getJcsCommandStation().addAccessoryEventListener((AccessoryEventListener) tile);      }      case SIGNAL -> {        tile = new Signal(tileBean);        tile.setAccessoryBean(tileBean.getAccessoryBean());        signalIdSeq = maxIdSeq(signalIdSeq, nextIdSeq(tileBean.getId()));        if (showValues && tileBean.getAccessoryBean() != null) {          ((Signal) tile).setSignalValue(((AccessoryBean) tileBean.getAccessoryBean()).getSignalValue());        }        JCS.getJcsCommandStation().addAccessoryEventListener((AccessoryEventListener) tile);      }      case SENSOR -> {        tile = new Sensor(tileBean);        tile.setSensorBean(tileBean.getSensorBean());        sensorIdSeq = maxIdSeq(sensorIdSeq, nextIdSeq(tileBean.getId()));        if (showValues && tileBean.getSensorBean() != null) {          ((Sensor) tile).setActive(((SensorBean) tileBean.getSensorBean()).isActive());        }        JCS.getJcsCommandStation().addSensorEventListener((SensorEventListener) tile);      }      case BLOCK -> {        tile = new Block(tileBean);        tile.setBlockBean(tileBean.getBlockBean());        blockIdSeq = maxIdSeq(blockIdSeq, nextIdSeq(tileBean.getId()));      }      case STRAIGHT_DIR -> {        tile = new StraightDirection(tileBean);        straightDirectionIdSeq = maxIdSeq(straightDirectionIdSeq, nextIdSeq(tileBean.getId()));      }      case END -> {        tile = new End(tileBean);        endIdSeq = maxIdSeq(endIdSeq, nextIdSeq(tileBean.getId()));      }      default ->        Logger.warn("Unknown Tile Type " + tileType);    }    return (Tile) tile;  }  public static void rollback(Tile tile) {    switch (tile.tileType) {      case STRAIGHT -> {        straightIdSeq--;      }      case CROSSING -> {        crossingIdSeq--;      }      case CURVED -> {        curvedIdSeq--;      }      case SWITCH -> {        switchIdSeq--;      }      case CROSS -> {        crossIdSeq--;      }      case SIGNAL -> {        signalIdSeq--;      }      case SENSOR -> {        sensorIdSeq--;      }      case BLOCK -> {        blockIdSeq--;      }      case STRAIGHT_DIR -> {        straightDirectionIdSeq--;      }      case END -> {        endIdSeq--;      }    }  }  /**   * @param tileType type of type to create   * @param orientation whether the orientation of the Tile is EAST, WEST, NORTH or SOUTH   * @param x the tile center X   * @param y the tile center Y   * @return a Tile object   */  public static Tile createTile(TileBean.TileType tileType, Orientation orientation, int x, int y) {    return createTile(tileType, orientation, Direction.CENTER, x, y);  }  /**   * @param tileType type of type to create   * @param orientation whether the orientation of the Tile is EAST, WEST, NORTH or SOUTH   * @param direction direction plays a role with Turnout tiles whether it goes to the Left or Right   * @param x the tile center X   * @param y the tile center Y   * @return a Tile object   */  public static Tile createTile(TileBean.TileType tileType, Orientation orientation, Direction direction, int x, int y) {    return createTile(tileType, orientation, direction, new Point(x, y));  }  public static Tile createTile(TileBean.TileType tileType, Orientation orientation, Direction direction, Point center) {    Tile tile = null;    switch (tileType) {      case STRAIGHT -> {        tile = new Straight(orientation, center);      }      case CROSSING -> {        tile = new Crossing(orientation, center);      }      case CURVED ->        tile = new Curved(orientation, center);      case SWITCH ->        tile = new Switch(orientation, direction, center);      case CROSS ->        tile = new Cross(orientation, direction, center);      case SIGNAL ->        tile = new Signal(orientation, center);      case SENSOR ->        tile = new Sensor(orientation, center);      case BLOCK ->        tile = new Block(orientation, center);      case STRAIGHT_DIR ->        tile = new StraightDirection(orientation, center);      case END ->        tile = new End(orientation, center);      default ->        Logger.warn("Unknown Tile Type " + tileType);    }    if (tile != null) {      tile.setId(nextTileId(tileType));    }    return (Tile) tile;  }  public static List<Tile> toTiles(List<TileBean> tileBeans, boolean drawOutline, boolean showValues) {    List<Tile> tileList = new LinkedList<>();    for (TileBean tileBean : tileBeans) {      Tile tile = createTile(tileBean, showValues);      tileList.add(tile);    }    return tileList;  }}